<!DOCTYPE html>
<html>

<head>
    <title>Crop and Edit</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
    <style>
        dialog {
            background-color: var(--background500);
            color: var(--foreground500);
            border: none;
            border-radius: 6px;
            padding: 10px 30px
        }

        dialog>header:first-child {
            background-color: var(--background600);
            border-radius: 6px 6px 0 0;
            margin: -10px -30px 10px;
            padding: 10px;
            text-align: center
        }

        dialog::backdrop {
            background: #0000009c;
            backdrop-filter: blur(4px)
        }

        input,
        select,
        textarea {
            width: 100%
        }

        button:focus,
        input:focus,
        select:focus,
        textarea:focus {
            box-shadow: 0 0 0 1px var(--primary500)
        }

        button:hover,
        input:hover,
        select:hover,
        textarea:hover {
            box-shadow: 0 0 0 1px var(--primary500)
        }

        button[readonly],
        input[readonly],
        select[readonly],
        textarea[readonly] {
            cursor: pointer;
            filter: brightness(80%)
        }

        button:disabled,
        input:disabled,
        select:disabled,
        textarea:disabled {
            cursor: not-allowed;
            filter: brightness(80%)
        }

        input[type=checkbox] {
            appearance: none;
            background-color: var(--background700);
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.15em;
            height: 1.15em;
            transform: translateY(-.075em);
            display: inline-grid;
            place-content: center;
            border-color: var(--background700)
        }

        input[type=checkbox]::before {
            content: "";
            width: .75em;
            height: .75em;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
            transform: scale(0);
            transform-origin: bottom left;
            transition: .2s transform ease-in-out;
            box-shadow: inset 1em 1em var(--primary500);
            background-color: CanvasText
        }

        input[type=checkbox]:checked::before {
            transform: scale(1)
        }

        input[type=checkbox]:focus {
            outline: 1px solid var(--primary500)
        }

        input[type=radio] {
            appearance: none;
            background-color: var(--background700);
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.15em;
            height: 1.15em;
            border-color: var(--background700);
            border-radius: 50%;
            transform: translateY(-.075em);
            display: inline-grid;
            place-content: center
        }

        input[type=radio]::before {
            content: "";
            width: .65em;
            height: .65em;
            border-radius: 50%;
            transform: scale(0);
            transition: .2s transform ease-in-out;
            box-shadow: inset 1em 1em var(--primary500);
            background-color: CanvasText
        }

        input[type=radio]:checked::before {
            transform: scale(1)
        }

        input[type=radio]:focus {
            outline: 1px solid var(--primary500)
        }

        select {
            background: var(--background600);
            padding-right: 35px;
            color: var(--foreground500);
            padding: 4px 8px
        }

        select::-ms-expand {
            display: none
        }

        select[multiple] {
            padding-right: 10px;
            background-image: none;
            overflow-y: auto
        }

        select option {
            background: var(--background600)
        }

        ::placeholder {
            color: var(--foreground600)
        }

        [type=checkbox][role=switch] {
            width: 2.475em;
            height: 1.25em;
            border-radius: 1.25em;
            background: linear-gradient(to right, var(--background600) 50%, var(--background700) 50%);
            line-height: 1.25em;
            padding-left: 1.6em
        }

        [type=checkbox][role=switch]:checked {
            background-image: none;
            background: linear-gradient(to right, var(--background600) 50%, var(--background700) 50%);
            padding-left: 1.6em
        }

        input[type=color] {
            height: 3.25em;
            padding: 4px;
            vertical-align: middle
        }

        [type=file] {
            border: 0;
            border-radius: 0;
            background: 0 0
        }

        [type=file]:hover {
            box-shadow: none
        }

        input[type=file]::file-selector-button {
            background-color: var(--background600);
            border: none;
            padding: 8px
        }

        input[type=file]::file-selector-button:hover {
            box-shadow: 0 0 0 1px var(--primary500)
        }

        button,
        input,
        textarea {
            background-color: var(--background600);
            color: var(--foreground500);
            border-radius: 2px;
            border: none;
            padding: 8px;
            transition: box-shadow var(--animation-duration) linear;
            margin: 1px
        }

        button,
        input[type=button],
        input[type=checkbox],
        input[type=radio],
        input[type=range],
        input[type=reset],
        input[type=submit],
        select {
            cursor: pointer
        }

        a {
            text-decoration: none;
            color: var(--primary500)
        }

        a:hover {
            text-decoration: none
        }

        hr {
            border: none;
            border-top: 1px solid var(--foreground600)
        }

        code,
        samp,
        time {
            color: var(--primary600);
            background-color: var(--background600);
            display: inline-block;
            padding: 2px 4px;
            border-radius: 6px
        }

        details {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background-color: var(--background550);
            padding: 10px 10px 0;
            margin: 1em 0;
            border-radius: 6px;
            overflow: hidden
        }

        details[open] {
            padding: 10px
        }

        details>:last-child {
            margin-bottom: 0
        }

        details[open] summary {
            margin-bottom: 10px
        }

        summary {
            display: list-item;
            background-color: var(--background600);
            padding: 10px;
            margin: -10px -10px 0;
            cursor: pointer;
            outline: 0
        }

        details>:not(summary) {
            margin-top: 0
        }

        var {
            color: var(--foreground600);
            font-style: normal;
            font-family: monospace
        }

        kbd {
            background: var(--background600);
            border-radius: 2px;
            color: var(--foreground500);
            padding: 2px 4px 2px 4px
        }

        fieldset {
            border: 1px var(--foreground600) solid;
            border-radius: 6px;
            margin: 0;
            padding: 10px
        }

        blockquote,
        q {
            border-left: 1px solid var(--foreground600);
            padding: 4px 8px
        }

        mark {
            background-color: var(--secondary500)
        }

        input[type=range] {
            -webkit-appearance: none;
            background: 0 0
        }

        input[type=range]:focus {
            outline: 0
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8.4px;
            cursor: pointer;
            background: var(--background700);
            border-radius: 1.3px;
            border: none
        }

        input[type=range]::-webkit-slider-thumb {
            border: none;
            height: 16px;
            width: 16px;
            background: var(--primary500);
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -4.2px;
            border-radius: 50%
        }

        input[type=range]:focus::-webkit-slider-runnable-track {
            background: var(--background700)
        }

        input[type=range]::-moz-range-track {
            width: 100%;
            height: 8.4px;
            cursor: pointer;
            background: var(--background700);
            border-radius: 1.3px;
            border: none
        }

        input[type=range]::-moz-range-thumb {
            border: none;
            height: 16px;
            width: 16px;
            background: var(--primary500);
            cursor: pointer;
            border-radius: 50%
        }

        input[type=range]::-ms-track {
            width: 100%;
            height: 8.4px;
            cursor: pointer;
            background: 0 0;
            border-color: transparent;
            border-width: 16px 0;
            color: transparent
        }

        input[type=range]::-ms-fill-lower {
            background: var(--background700);
            border: none;
            border-radius: 2.6px
        }

        input[type=range]::-ms-fill-upper {
            background: var(--background700);
            border: none;
            border-radius: 2.6px
        }

        input[type=range]::-ms-thumb {
            border: none;
            height: 16px;
            width: 16px;
            background: var(--primary500);
            cursor: pointer;
            border-radius: 50%
        }

        input[type=range]:focus::-ms-fill-lower {
            background: var(--background700)
        }

        input[type=range]:focus::-ms-fill-upper {
            background: var(--background700)
        }

        table {
            border-collapse: collapse;
            margin-bottom: 10px;
            width: 100%;
            table-layout: fixed
        }

        table caption {
            text-align: left
        }

        td,
        th {
            padding: 6px;
            text-align: left;
            vertical-align: top;
            word-wrap: break-word
        }

        thead {
            border-bottom: 1px solid var(--foreground600)
        }

        tfoot {
            border-top: 1px solid var(--foreground600)
        }

        tbody tr:nth-child(even) {
            background-color: var(--background550)
        }

        progress {
            display: inline-block;
            vertical-align: baseline
        }

        progress {
            -webkit-appearance: none;
            -moz-appearance: none;
            display: inline-block;
            appearance: none;
            width: 100%;
            height: .5rem;
            overflow: hidden;
            border: 0;
            border-radius: 6px;
            background-color: var(--background600);
            color: var(--primary500);
            margin-bottom: 6px
        }

        progress::-webkit-progress-bar {
            border-radius: 6px;
            background: 0 0
        }

        progress[value]::-webkit-progress-value {
            background-color: var(--primary500);
            -webkit-transition: inline-size var(--animation-duration);
            transition: inline-size var(--animation-duration)
        }

        progress::-moz-progress-bar {
            background-color: var(--primary500)
        }

        progress:indeterminate {
            background: var(--background600) linear-gradient(to right, var(--primary500) 30%, var(--background600) 30%) top left/150% 150% no-repeat;
            animation: progress-indeterminate 2s linear infinite
        }

        progress:indeterminate[value]::-webkit-progress-value {
            background-color: transparent
        }

        progress:indeterminate::-moz-progress-bar {
            background-color: transparent
        }

        [dir=rtl] progress:indeterminate {
            animation-direction: reverse
        }

        @keyframes progress-indeterminate {
            0% {
                background-position: 200% 0
            }

            100% {
                background-position: -200% 0
            }
        }

        [data-tooltip] {
            position: relative
        }

        [data-tooltip]::after,
        [data-tooltip]::before {
            display: block;
            z-index: 99;
            position: absolute;
            bottom: 100%;
            left: 50%;
            padding: .25rem .5rem;
            overflow: hidden;
            transform: translate(-50%, -.25rem);
            border-radius: 6px;
            background: var(--background600);
            content: attr(data-tooltip);
            color: var(--foreground500);
            font-style: normal;
            font-size: .875rem;
            text-decoration: none;
            text-overflow: ellipsis;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none
        }

        [data-tooltip]::after {
            padding: 0;
            transform: translate(-50%, 0);
            border-top: .3rem solid;
            border-right: .3rem solid transparent;
            border-left: .3rem solid transparent;
            border-radius: 0;
            background-color: transparent;
            content: "";
            color: var(--forground600)
        }

        [data-tooltip]:focus::after,
        [data-tooltip]:focus::before,
        [data-tooltip]:hover::after,
        [data-tooltip]:hover::before {
            opacity: 1
        }

        :root {
            --foreground500: #161f27;
            --foreground600: #0f151b;
            --background500: #ffffff;
            --background550: #f0f0ff;
            --background600: #e0e0e0;
            --background700: #c7c7c7;
            --primary500: #0172ad;
            --primary600: #014a85;
            --secondary500: #ffe1a8;
            --animation-duration: 200ms
        }

        [dir=rtl] {
            direction: rtl
        }

        html {
            scrollbar-color: var(--foreground500) var(--background500);
            scrollbar-width: thin
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;
            padding: 16px 16px;
            word-wrap: break-word;
            color: var(--foreground500);
            background: var(--background500);
            text-rendering: optimizeLegibility
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <input type="file" id="fileUploader" style="display: none;" accept="image/*" />
    <button onclick="document.getElementById('fileUploader').click();">Upload Image</button>
    <label>
        <input type="checkbox" id="histogramToggle" onchange="computeHistogram(this.checked)">
        Toggle Color Histogram
    </label>
    <button id="lightenButton">Lighten Image</button>
    <button id="darkenButton">Darken Image</button>
    <button id="grayscaleButton">Convert to Grayscale</button>
    <button id="download-btn">Download Image</button>
    <button id="rotateBtn">Rotate 45 Degrees</button>
    <button id="flipButton">Flip Vertical</button>
    <button id="flipButtonHorizontal">Flip Horizontal</button>
    <button id="contrastButton">Increase Contrast</button>
    <div id="histogram"></div>
    <div style="display: flex; flex-direction: column;">
        <div id="histogramr"></div>
        <div id="histogramg"></div>
        <div id="histogramb"></div>
    </div>
    <script>
        let imageData;
        let showColorHistogram;
        let imageDataSetAfterDrag = false;
        let overlayCanvas;
        let histCoords;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const histogramElement = document.getElementById('histogram');
        const histogramElementR = document.getElementById('histogramr');
        const histogramElementG = document.getElementById('histogramg');
        const histogramElementB = document.getElementById('histogramb');
        let img = new Image();
        img.src = 'castle1.png'; // Replace with the path to your image
        img.onload = function () {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            addOverlay();
        };

        // Set up the file uploader event listener
        document.getElementById('fileUploader').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    img.src = e.target.result;  // Set image source to the file content
                    addOverlay();
                };
                reader.readAsDataURL(file);  // Read the file as Data URL
            }
        });

        let isFlippedHorizontally = false;
        let isFlippedVertically = false;

        function applyTransformations() {
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Reset transformations to default
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            // Apply horizontal flip if needed
            if (isFlippedHorizontally) {
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
            }

            // Apply vertical flip if needed
            if (isFlippedVertically) {
                ctx.translate(0, canvas.height);
                ctx.scale(1, -1);
            }

            // Redraw the image with current transformations
            ctx.drawImage(img, 0, 0);
            if (histCoords) {
                createHistogram(histCoords.startX, histCoords.startY, histCoords.width, histCoords.height);
            }
        }

        function flipImageHorizontally() {
            // Toggle the horizontal flip state
            isFlippedHorizontally = !isFlippedHorizontally;
            applyTransformations(); // Apply the current transformations
        }

        function flipImageVertically() {
            // Toggle the vertical flip state
            isFlippedVertically = !isFlippedVertically;
            applyTransformations(); // Apply the current transformations
        }

        document.getElementById('flipButtonHorizontal').addEventListener('click', flipImageHorizontally);
        document.getElementById('flipButton').addEventListener('click', flipImageVertically);

        const rotateBtn = document.getElementById('rotateBtn');
        let angle = 0; // Initialize angle of rotation

        rotateBtn.addEventListener('click', function () {
            angle += 45; // Increase angle by 45 degrees each click
            angle = angle % 360; // Keep the angle within 0-359 degrees

            // Clear the canvas and redraw the image rotated
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save(); // Save the current state
            ctx.translate(canvas.width / 2, canvas.height / 2); // Move the origin to the center of the canvas
            ctx.rotate(angle * Math.PI / 180); // Convert degrees to radians and rotate
            ctx.drawImage(img, -img.width / 2, -img.height / 2); // Draw the image centered at the origin
            ctx.restore(); // Restore the original state
            if (histCoords) {
                createHistogram(histCoords.startX, histCoords.startY, histCoords.width, histCoords.height);
            }
        });

        let startX, startY, isDragging = false;

        document.getElementById('download-btn').addEventListener('click', function () {
            downloadImageDataAsImage(imageData, 'downloaded.png'); // Trigger download
        });

        function downloadImageDataAsImage(imageData, filename) {
            if (!imageDataSetAfterDrag) {
                imageData = ctx.getImageData(0, 0, img.width, img.height);
            }

            // Create a new canvas element
            const canvas = document.createElement('canvas');
            canvas.width = imageData.width;
            canvas.height = imageData.height;

            // Get context of the new canvas and put imageData into it
            const ctxNew = canvas.getContext('2d');
            ctxNew.putImageData(imageData, 0, 0);

            // Convert canvas to data URL and trigger download
            const imageURL = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = imageURL;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function linearScaleContrast(luminance) {
            if (luminance < 25 || luminance > 230) {
                return luminance;
            }

            return (0.7512 + (0.00195 * luminance)) * luminance;
        }

        document.getElementById('contrastButton').addEventListener('click', function () {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = linearScaleContrast(data[i]);
                data[i + 1] = linearScaleContrast(data[i + 1]);
                data[i + 2] = linearScaleContrast(data[i + 2]);
            }

            // Write the grayscale image data back to the canvas
            ctx.putImageData(imageData, 0, 0);
            if (histCoords) {
                createHistogram(histCoords.startX, histCoords.startY, histCoords.width, histCoords.height);
            }
        });

        document.getElementById('grayscaleButton').addEventListener('click', function () {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const red = data[i];
                const green = data[i + 1];
                const blue = data[i + 2];
                // Calculate the luminance
                const luminance = 0.299 * red + 0.587 * green + 0.114 * blue;
                // Set the red, green, and blue pixels to the luminance
                data[i] = data[i + 1] = data[i + 2] = luminance;
            }

            // Write the grayscale image data back to the canvas
            ctx.putImageData(imageData, 0, 0);
            img.src = canvas.toDataURL(); // Convert canvas content to a data URL
            if (histCoords) {
                createHistogram(histCoords.startX, histCoords.startY, histCoords.width, histCoords.height);
            }
        });

        document.getElementById('lightenButton').addEventListener('click', function () {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = data[i] * 1.1;     // R
                data[i + 1] = data[i + 1] * 1.1; // G
                data[i + 2] = data[i + 2] * 1.1; // B
            }

            ctx.putImageData(imageData, 0, 0);
            if (histCoords) {
                createHistogram(histCoords.startX, histCoords.startY, histCoords.width, histCoords.height);
            }
        });

        document.getElementById('darkenButton').addEventListener('click', function () {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] *= 0.9;     // Red
                data[i + 1] *= 0.9; // Green
                data[i + 2] *= 0.9; // Blue
                // Alpha (data[i + 3]) remains unchanged
            }

            ctx.putImageData(imageData, 0, 0);
            if (histCoords) {
                createHistogram(histCoords.startX, histCoords.startY, histCoords.width, histCoords.height);
            }
        });

        canvas.onmousedown = function (e) {
            let { mouseX, mouseY } = adjustMouseCoordinates(e);
            startX = mouseX;
            startY = mouseY;
            isDragging = true;
        };

        function adjustMouseCoordinates(e) {
            let mouseX = e.offsetX;
            let mouseY = e.offsetY;

            // Adjust for horizontal flip
            if (isFlippedHorizontally) {
                mouseX = canvas.width - mouseX;
            }

            // Adjust for vertical flip
            if (isFlippedVertically) {
                mouseY = canvas.height - mouseY;
            }

            return { mouseX, mouseY };
        }

        function addOverlay() {
            if (overlayCanvas && document.body.contains(overlayCanvas)) {
                document.body.removeChild(overlayCanvas);
            }

            // Create an overlay canvas for drawing rectangles
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    overlayCanvas = document.createElement('canvas');

                    overlayCanvas.width = canvas.width;
                    overlayCanvas.height = canvas.height;
                    overlayCanvas.style.position = 'absolute';
                    overlayCanvas.style.top = canvas.offsetTop + 'px';
                    overlayCanvas.style.left = canvas.offsetLeft + 'px';
                    overlayCanvas.style.pointerEvents = 'none'; // Prevent interfering with mouse events
                    document.body.appendChild(overlayCanvas);

                    const overlayCtx = overlayCanvas.getContext('2d');

                    // Adjust existing event handlers to use the overlay
                    canvas.onmousemove = function (e) {
                        if (isDragging) {
                            let { mouseX, mouseY } = adjustMouseCoordinates(e);
                            const width = mouseX - startX;
                            const height = mouseY - startY;

                            // Clear the overlay canvas
                            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                            // Draw the rectangle on the overlay canvas
                            overlayCtx.beginPath();
                            const lineWidth = 2;
                            overlayCtx.rect(startX - lineWidth, startY - lineWidth, width + lineWidth * 2, height + lineWidth * 2);
                            overlayCtx.strokeStyle = 'red';
                            overlayCtx.lineWidth = lineWidth;
                            overlayCtx.stroke();
                        }
                    };

                    canvas.onmouseup = function (e) {
                        isDragging = false;
                        let { mouseX, mouseY } = adjustMouseCoordinates(e);
                        const width = mouseX - startX;
                        const height = mouseY - startY;

                        histCoords = { startX, startY, width, height };

                        // Keep the overlay canvas as is for the rectangle
                        createHistogram(startX, startY, width, height);
                        imageDataSetAfterDrag = true;
                    };

                    // Handle touch events for the overlay similarly
                    canvas.addEventListener('touchmove', function (e) {
                        e.preventDefault();
                        if (isDragging) {
                            const touch = e.touches[0];
                            const { mouseX, mouseY } = adjustTouchCoordinates(touch);
                            const width = mouseX - startX;
                            const height = mouseY - startY;

                            // Clear the overlay canvas
                            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                            // Draw the rectangle on the overlay canvas
                            overlayCtx.beginPath();
                            const lineWidth = 2;
                            overlayCtx.rect(startX - lineWidth, startY - lineWidth, width + lineWidth * 2, height + lineWidth * 2);
                            overlayCtx.strokeStyle = 'red';
                            overlayCtx.lineWidth = lineWidth;
                            overlayCtx.stroke();
                        }
                    });
                })
            })
        }

        // Touch event handlers
        canvas.addEventListener('touchstart', function (e) {
            e.preventDefault(); // Prevent default touch behavior (e.g., scrolling)
            const touch = e.touches[0]; // Get the first touch point
            const { mouseX, mouseY } = adjustTouchCoordinates(touch);
            startX = mouseX;
            startY = mouseY;
            isDragging = true;
        });

        canvas.addEventListener('touchend', function (e) {
            e.preventDefault(); // Prevent default touch behavior
            isDragging = false;
            const touch = e.changedTouches[0]; // Get the last touch point
            const { mouseX, mouseY } = adjustTouchCoordinates(touch);
            const width = mouseX - startX;
            const height = mouseY - startY;

            histCoords = { startX, startY, width, height };

            createHistogram(startX, startY, width, height);
            imageDataSetAfterDrag = true;
        });

        // Adjust touch coordinates to canvas space
        function adjustTouchCoordinates(touch) {
            const rect = canvas.getBoundingClientRect(); // Get canvas bounding box
            let mouseX = touch.clientX - rect.left;
            let mouseY = touch.clientY - rect.top;

            // Adjust for horizontal flip
            if (isFlippedHorizontally) {
                mouseX = canvas.width - mouseX;
            }

            // Adjust for vertical flip
            if (isFlippedVertically) {
                mouseY = canvas.height - mouseY;
            }

            return { mouseX, mouseY };
        }

        function createHistogram(x, y, width, height) {
            if (width === 0 || height === 0) {
                return;
            }

            imageData = ctx.getImageData(x, y, width, height);
            computeHistogram(this.checked);
        }

        function computeHistogram(isColor = false) {
            if (isColor !== null && isColor !== undefined) {
                showColorHistogram = isColor;
            }

            if (!imageData) {
                return;
            }

            const data = imageData.data;

            if (!showColorHistogram) {
                let luminanceHistogram = new Array(256).fill(0);

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                    luminanceHistogram[Math.floor(luminance)]++;
                }

                displayHistogram(luminanceHistogram);
            } else {
                let luminanceHistogramR = new Array(256).fill(0);
                let luminanceHistogramG = new Array(256).fill(0);
                let luminanceHistogramB = new Array(256).fill(0);

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    luminanceHistogramR[r]++;
                    luminanceHistogramG[g]++;
                    luminanceHistogramB[b]++;
                }

                displayColorHistogram(luminanceHistogramR, luminanceHistogramG, luminanceHistogramB);
            }
        }

        function displayHistogram(histogram) {
            histogramElement.innerHTML = '';
            histogramElementR.innerHTML = '';
            histogramElementG.innerHTML = '';
            histogramElementB.innerHTML = '';

            histogramElement.style.height = '100px';
            histogramElement.style.width = 'max(50%, 500px)';

            histogramElementR.style.height = '';
            histogramElementR.style.width = '';

            histogramElementG.style.height = '';
            histogramElementG.style.width = '';

            histogramElementB.style.height = '';
            histogramElementB.style.width = '';

            // Use setTimeout to ensure the style is applied and rendered
            setTimeout(() => {
                // Get the computed style of the element
                const computedStyle = window.getComputedStyle(histogramElement);
                // Access the width property, which gives the final computed width in pixels
                let computedWidth = computedStyle.width;

                if (computedWidth.includes('px')) {
                    computedWidth = computedWidth.replace('px', '');
                }

                computedWidth = Number(computedWidth);

                const maxCount = Math.max(...histogram);
                histogram.forEach((count, i) => {
                    const bar = document.createElement('div');
                    bar.style.width = `${computedWidth / 255}px`;
                    bar.style.height = `${(count / maxCount) * 100}%`;
                    bar.style.backgroundColor = 'black';
                    bar.style.display = 'inline-block';
                    histogramElement.appendChild(bar);
                });
            }, 0);
        }

        function displayColorHistogram(histogramR, histogramG, histogramB) {
            histogramElement.innerHTML = '';
            histogramElementR.innerHTML = '';
            histogramElementG.innerHTML = '';
            histogramElementB.innerHTML = '';

            histogramElement.style.height = '';
            histogramElement.style.width = '';

            histogramElementR.style.height = '100px';
            histogramElementR.style.width = 'max(50%, 500px)';

            histogramElementG.style.height = '100px';
            histogramElementG.style.width = 'max(50%, 500px)';

            histogramElementB.style.height = '100px';
            histogramElementB.style.width = 'max(50%, 500px)';

            // Use setTimeout to ensure the style is applied and rendered
            setTimeout(() => {
                // Get the computed style of the element
                const computedStyle = window.getComputedStyle(histogramElementR);
                // Access the width property, which gives the final computed width in pixels
                let computedWidth = computedStyle.width;

                if (computedWidth.includes('px')) {
                    computedWidth = computedWidth.replace('px', '');
                }

                computedWidth = Number(computedWidth);

                const maxCountR = Math.max(...histogramR);
                histogramR.forEach((count, i) => {
                    const bar = document.createElement('div');
                    bar.style.width = `${computedWidth / 255}px`;
                    bar.style.height = `${(count / maxCountR) * 100}%`;
                    bar.style.backgroundColor = 'red';
                    bar.style.display = 'inline-block';
                    histogramElementR.appendChild(bar);
                });

                const maxCountG = Math.max(...histogramG);
                histogramG.forEach((count, i) => {
                    const bar = document.createElement('div');
                    bar.style.width = `${computedWidth / 255}px`;
                    bar.style.height = `${(count / maxCountG) * 100}%`;
                    bar.style.backgroundColor = 'green';
                    bar.style.display = 'inline-block';
                    histogramElementG.appendChild(bar);
                });

                const maxCountB = Math.max(...histogramB);
                histogramB.forEach((count, i) => {
                    const bar = document.createElement('div');
                    bar.style.width = `${computedWidth / 255}px`;
                    bar.style.height = `${(count / maxCountB) * 100}%`;
                    bar.style.backgroundColor = 'blue';
                    bar.style.display = 'inline-block';
                    histogramElementB.appendChild(bar);
                });
            }, 0);
        }
    </script>
</body>

</html>